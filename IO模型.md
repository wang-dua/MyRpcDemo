# IO模型 (结合socket编程中应用进程与内核缓冲区的读写理解)

### 阻塞非阻塞IO

BIO 阻塞IO : 进程发现内核缓冲区 **读空, 写满,** 会阻塞

NIO 非阻塞IO:  进程不会阻塞, 一直轮询, 占用 CPU

### 同步异步IO (以read write为例)

同步IO: 应用进程在读写数据的时候不能做其他任务

异步IO: 进程在在读写数据的时候可以做其他任务

也就是说同步异步 仅在读写数据的时候有意义

|          |                             阻塞                             |                            非阻塞                            |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| **同步** | read(write): 发现buffer空(满), 阻塞, 让出CPU, buffer不为空, 则读(写)数据的时候不能做其他任务 | read(write): 发现buffer空(满), 占用CPU轮询, buffer不为空, 则读(写)数据的时候不能做其他任务, 配合多路复用 |
| **异步** |                            **×**                             | read(write): 发现buffer空(满), 占用CPU轮询, buffer不为空, 则读(写)数据的时候可以做其他任务, 配合多路复用 |

### IO多路复用(多路转接)

**socket通信中返回的文件描述符 (file description), 可以理解为文件索引, 用于内核态找到文件并处理**, 当多个客户端与服务端进行socket通信时, 需要用到多路复用

1. 一个客户端想要连接服务端, 使用connect(), 返回一个连接fd, 使用read() write()收发数据
2. 服务端通过监听listenfd(只有一个), 读取到connect请求,  accept()发现listenfd变得可读, 接受客户端的连接, 并返回一个连接connfd, 与客户端进行收发数据
3. 但是当监听到多个客户端的连接时 connfd, 如果线性处理, 客户端没有发送数据, 服务器变回进入阻塞状态等待消息(或者一直轮询查看有无消息), 下面的客户端不能与服务端通信
4. 而进行多路复用: 把所有的 connfd交给内核处理, 哪一个connfd可读或可写或异常就交给用户处理, 更高效. 





