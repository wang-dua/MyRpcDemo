# zookeeper

 在rpc (remote procedure call)中, 调用方调用远程服务器中的方法就像调用本地方法一样, **ZooKeeper**在这里作为服务方法的管理配置中心，负责管理服务方法提供者对外提供的服务方法。服务方法提供者提前将本端对外提供的服务方法名及自己的通信地址信息（IP:Port）注册到ZooKeeper。当Caller发起远端调用时，会先拿着自己想要调用的服务方法名询问ZooKeeper，ZooKeeper告知Caller想要调用的服务方法在哪台服务器上（ZooKeeper返回目标服务器的IP:Port给Caller），Caller便向目标服务器请求服务方法调用。目标服务器在本地执行相应服务方法后将结果返回给Caller。

# protobuf

**Protobuf 就是客户端和服务端约定的一种“通信格式”**，把要说的内容（方法、参数、返回值）都**压缩、编码成高效的二进制数据**，这样：

1. 传输更快（数据小）。

2. 不会产生歧义（双方用同一个 `.proto` 定义文件，保证理解一致）。

3. 解码时能还原成原始的数据结构（比如对象、类）。

   **RPC 中，Protobuf 就是用来定义接口和消息格式，并负责在客户端和服务端之间高效、无歧义地传输数据的工具。**
   
   **`.proto` 文件就像菜单：上面写着菜名（函数名）、需要的食材（参数）、上菜的样子（返回值）。**
   
   **客户端就像顾客：点菜的时候，只管说“我要一份番茄炒蛋（RPC 调用）”。**
   
   **Protobuf 就像服务员的点餐系统：把菜名和需求转成数字编码（序列化），传到厨房。**
   
   **厨房（服务端）根据菜单做菜（执行逻辑），再把做好的菜装盘（打包返回值），送回给顾客**

# muduo 库

1. **基于 Reactor 模式**：用 epoll 管理所有连接，单线程就能处理成千上万连接。
2. **事件驱动**：你只需要写“当收到数据时怎么处理”的回调函数，框架帮你监听和调度事件。
3. **线程池**：可以很容易地把任务交给多线程执行，避免阻塞主线程。
4. **简化网络编程**：不用直接和 `socket/epoll` 打交道，封装成 C++ 对象和回调。



## 总结协作关系

1. **Protobuf** → 定义消息和接口，负责序列化/反序列化
2. **RPC 框架** → 网络通信 + 请求派发 + 调用服务
3. **Zookeeper** → 动态服务注册和发现，解决服务实例多和负载均衡问题

通俗理解：

- **Protobuf** = 快递包装盒，把消息打包好
- **RPC 框架** = 快递运输公司，把包裹送到正确地址
- **Zookeeper** = 快递地址簿，告诉你去哪找收件人